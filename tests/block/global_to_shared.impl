template<int H, int W, ducks::st_layout::all L, int WORKERS=8>
__global__ void test_block_copy_ker(const bf16 *input, bf16 *output) {
    using block = kittens::block<WORKERS>;
    constexpr int COLS = W*16;

    extern __shared__ __align__(16) int __shm[]; // this is the CUDA shared memory
    shared_allocator al((int*)&__shm[0]);
    
    st_bf<H, W, L> &smem_tile = al.allocate<st_bf<H, W, L>>(); 

    auto tblock = cooperative_groups::this_thread_block();
    __shared__ cuda::barrier<cuda::thread_scope::thread_scope_block> barrier;
    if (threadIdx.x == 0) {init(&barrier, tblock.size());}
    tblock.sync();

    block::load_async(smem_tile, input, COLS, barrier);
    barrier.arrive_and_wait();

    block::store_async(output, smem_tile, COLS, barrier);
    barrier.arrive_and_wait();
}
template<int H, int W, ducks::st_layout::all L, int WORKERS=8>
bool test_block_copy() {
    constexpr int SIZE = W*H*256;
    // initailize
    bf16 *d_i, *d_o;
    std::vector<float> i_ref(SIZE);
    std::vector<float> o_ref(SIZE);
    initialize(&d_i, &d_o, i_ref, o_ref);
    // run kernel
    cudaFuncSetAttribute(test_block_copy_ker<H,W,L,WORKERS>, cudaFuncAttributeMaxDynamicSharedMemorySize, 100000);
    test_block_copy_ker<H,W,L,WORKERS><<<1, WORKERS*32, 100000>>>(d_i, d_o);
    // fill in correct results on cpu
    for(int i = 0; i < SIZE; i++) o_ref[i] = i_ref[i];
    // check and cleanup
    std::string load_str;
    load_str += "_"+std::to_string(H)+"x"+std::to_string(W);
    load_str += "_"+layout_name<L>();
    load_str += "_"+std::to_string(WORKERS)+"WARP";
    bool passed = validate(d_i, d_o, i_ref, o_ref, "block_global_shared_copy_tile"+load_str, 16 * W); 
    return passed;
}

template<int H, int W, ducks::st_layout::all L>
int sweep_block_copy_workers() {
    int failures = 0;
    failures += !test_block_copy<H,W,L,1>();
    failures += !test_block_copy<H,W,L,2>();
    failures += !test_block_copy<H,W,L,3>();
    failures += !test_block_copy<H,W,L,4>();
    failures += !test_block_copy<H,W,L,5>();
    failures += !test_block_copy<H,W,L,6>();
    failures += !test_block_copy<H,W,L,7>();
    failures += !test_block_copy<H,W,L,8>();
    failures += !test_block_copy<H,W,L,9>();
    failures += !test_block_copy<H,W,L,10>();
    failures += !test_block_copy<H,W,L,11>();
    failures += !test_block_copy<H,W,L,12>();
    failures += !test_block_copy<H,W,L,13>();
    failures += !test_block_copy<H,W,L,14>();
    failures += !test_block_copy<H,W,L,15>();
    failures += !test_block_copy<H,W,L,16>();
    return failures;
}
template<int H, int W>
int sweep_block_copy_layout() {
    int failures = 0;
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::naive>();
    if constexpr (W==1 || W == 2 || W == 4)
        failures += sweep_block_copy_workers<H, W, ducks::st_layout::tma_swizzle>();
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::xor_swizzle>();
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::wgmma_row_0b>();
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::wgmma_row_32b>();
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::wgmma_col_t_0b>();
    failures += sweep_block_copy_workers<H, W, ducks::st_layout::wgmma_col_t_32b>();
    return failures;
}
int sweep_block_copy_size() {
    int failures = 0;
    failures += sweep_block_copy_layout<1, 1>();
    failures += sweep_block_copy_layout<1, 2>();
    failures += sweep_block_copy_layout<1, 3>();
    failures += sweep_block_copy_layout<1, 4>();
    failures += sweep_block_copy_layout<1, 6>();
    failures += sweep_block_copy_layout<1, 8>();
    failures += sweep_block_copy_layout<2, 1>();
    failures += sweep_block_copy_layout<2, 2>();
    failures += sweep_block_copy_layout<2, 3>();
    failures += sweep_block_copy_layout<2, 4>();
    failures += sweep_block_copy_layout<2, 6>();
    failures += sweep_block_copy_layout<2, 8>();
    failures += sweep_block_copy_layout<3, 1>();
    failures += sweep_block_copy_layout<3, 2>();
    failures += sweep_block_copy_layout<3, 3>();
    failures += sweep_block_copy_layout<3, 4>();
    failures += sweep_block_copy_layout<3, 6>();
    failures += sweep_block_copy_layout<3, 8>();
    failures += sweep_block_copy_layout<4, 1>();
    failures += sweep_block_copy_layout<4, 2>();
    failures += sweep_block_copy_layout<4, 3>();
    failures += sweep_block_copy_layout<4, 4>();
    failures += sweep_block_copy_layout<4, 6>();
    failures += sweep_block_copy_layout<4, 8>();
    failures += sweep_block_copy_layout<6, 1>();
    failures += sweep_block_copy_layout<6, 2>();
    failures += sweep_block_copy_layout<6, 3>();
    failures += sweep_block_copy_layout<6, 4>();
    failures += sweep_block_copy_layout<6, 6>();
    failures += sweep_block_copy_layout<6, 8>();
    failures += sweep_block_copy_layout<8, 1>();
    failures += sweep_block_copy_layout<8, 2>();
    failures += sweep_block_copy_layout<8, 3>();
    failures += sweep_block_copy_layout<8, 4>();
    failures += sweep_block_copy_layout<8, 6>();
    failures += sweep_block_copy_layout<8, 8>();
    return failures;
}


int block_mem_tests() {
    std::cout << " ----- Starting block mem tests! -----" << std::endl;
    int failures = 0;
    failures += sweep_block_copy_size();
    return failures;
}